# wb-money
Тестовое задание от Wildberries &amp; Russ. Внутренняя аналитика Портала Продавцов.
### Выполнил: Бугренков Владимир Петрович
#### Ссылка на репозиторий: https://github.com/Qwental/wb-money


**Вопрос 1. Предложите несколько продуктовых фичей, которые помогут развивать WB Кошелёк как способ оплаты.**

Основные фичи, которые я могу предложить:
1. ФИЧА №1: Сделать баннер, который будет интегрирован в мобильном приложении и на сайт WB, в котором будем писать пользователю сколько пользователь сэкономил бы денег, если бы он все покупки оплачивал с помощью WB-кошелька. Таким образом, у пользователя может появиться чувство FOMO (fear of missing out), и он с большим шансом решит оформить WB-кошелек, чтобы больше не терять выгоду. Данную фичу я реализовал на микросервисах; код, архитектура решения, обоснование принятых решений, перспективы развития(что можно улучшить и доработать) и инструкция по развертыванию и запуску есть далее по тексту.
   Пример работы баннера. (Пример сделан на основе сгенерерованных данных).
   ![Screenshot of wb-money](images_for_readme/Pasted%20image%2020250614003126.png)
2. ФИЧА №2: Геймификация: Например каждые N заказов оплаченных WB-кошельком увеличивать проценты кешбека. Тем самым пользователь будет хотеть все больше и больше тратиться на покупки, чтобы повышать свой кешбек. Данная фича может быть реализуема, только если разрешат пользователям повышать кешбек больше 3%
3. ФИЧА №3: Кешбек-бустер: Для новых пользователей повышать временно кешбек по WB-кошельку, например до 5%. При этом должно учитывается, что один человек может завести один WB-кошелек, чтобы не было ситуации, что пользователь будет создавать кучу новых аккаунтов.
4. ФИЧА №4: Фича по ТЗ, сделать использование WB-кошелька способом оплаты по умолчанию.

---

**Вопрос 2. Какую статистику нужно собрать, чтобы понять, имеет ли смысл тратить ресурсы команды на разработку и тестирование данной фичи?**

Для ФИЧИ №1 (баннера) таблицы product_events может быть недостаточно, ввиду того что данные в ней могут не достоверны, потому что в таблице отражаются только следущие события:
- open_app - в параметрах события записано, на какой платформе устройство, с которого был выполнен вход в приложение;
- cart - событие показа экрана, в параметрах напишем общую сумму товаров в корзине, их количество и тд;
- payment_methods - показ окна с методами оплаты, напишем в параметрах default method -_метод оплаты, выбранный по умолчанию, и еще несколько других параметров;
- buy - событие покупки, сумма покупки, кол-во товаров в заказе и метод оплаты для заказа.


Для полноценной оценки эффективности ФИЧИ №1 (баннер ) необходимо расширить сбор данных событий product_events

Также необходимо составить статистику:
- Сколько процентов пользователей после просмотра баннера пошли оформлять  WB-кошелек.
- Сколько процентов пользователей после просмотра баннера следующую покупку оформили по WB-кошельку
- Собрать метрики CTR баннера


В ней для полной работы ФИЧИ №1 (баннер) критически не хватает события, отвечающее за возврат средств по гарантии или после примерки. То есть было бы хорошо, если у покупки был свой ID, по нему отслеживать, что пользователь не вернул деньги за заказ. Пусть это будет событие order_return, если пользователь вернул заказ
Также для составления метрик CTR,  нужно добавить события product_events - banner_view

Можно составить два варианта метрики
1) CTR = (Число пользователей, сразу перешедших в корзину после просмотра баннера ) / (число пользователей увидевших баннер banner_view и не имеющие карту WB )

2)  CTR = (Число пользователей следующую покупку оформили по WB-кошельку после просмотра баннера ) / (число пользователей увидевших баннер banner_view и не имеющие карту WB )

Я решил, что пусть в таблице product_events хранятся заказы, которые пользователь не возвращал средства за заказ. Так мне проще будет делать реализацию фичи.

Пример таблицы product_events. В рамках моего решения ФИЧИ №1, я использую СУБД Clickhouse.

| timestamp           | user_id | event_name       | parameters                                                                  |
| ------------------- | ------- | ---------------- | --------------------------------------------------------------------------- |
| 2025-05-01 00:03:27 | 1342    | open_app         | {"platform": "ios", "region": "RU"}                                         |
| 2025-05-01 00:04:11 | 1342    | cart             | {"total_amount": 679, "currency": "RUB", "n_goods": 12, "goods_list": ...}  |
| 2025-05-01 00:04:11 | 1342    | payment_methods  | {"default_method": "wallet", ...}                                           |
| 2025-05-01 00:05:45 | 1342    | buy              | {"amount": 320, "currency": "RUB", "n_goods": 1, "payment_method":"wallet"} |

**Вопрос 3. Какое решение можно принять на основе этих данных? Нужно ли дополнительно исследовать другие показатели и, если да, то какие?**


Далее ответим сразу на 3 вопрос: Допустим, что мы приняли решение разработать и протестировать ФИЧУ №1 (баннер). Для этого мы провели АБ-тест, в котором получились следующие результаты для групп А (контроль, предвыбора нет) и Б(тест, предвыбор есть):
- в группе Б стат. значимо выросла метрика доли GMV кошелька от общего GMV с 11% до 15% по сравнению с группой А;
- в группе Б стат. значимо выросла метрика выручки с методом оплаты кошелек в расчете на 1 пользователя корзины с 1000 рублей до 1300 рублей по сравнению с группой А.

Ответ:
Рост GMV кошелька на 36% (15% vs 11%) — статистически очень значимый эффект. В  2023 год на WB  оформили 575 миллионов заказов. Эти 4% от этих миллионов очень значимый.
Увеличение ARPU на 30% (1300₽ vs 1000₽) — подтверждает ценность фичи


Также можно сравнивать новых пользователей и старых. Платформы пользователей: допустим люди с IOS и Android могут по разному подходить к финансовой граммотности.

Итого ФИЧА  № 1 (баннер) успешна, но требуют дополнительные данные.

**Вопрос 4. Напишите код на SQL, который позволит посчитать:**
- **какая доля пользователей от тех, которые увидели окно методов оплаты, имели предвыбранный способ оплаты «Кошелек»;**
- **какая доля пользователей от тех, которые открыли приложение, сделала покупку со способом оплаты «Кошелек»**

Решение данного вопроса есть в репозитории в виде микросервиса wallet_payment_analyzer (пример полученных данных: `{"wallet_payment_methods_share":0.8301886792452831,"wallet_purchase_share":0.6851851851851852}` ), но я продублирую SQL запросы сюда. Работаю я в рамках моей реализации с Clickhouse


```
SELECT  
    COUNT(DISTINCT CASE WHEN JSONExtractString(parameters, 'default_method') = 'wallet' THEN user_id END) /  
    COUNT(DISTINCT user_id) AS wallet_payment_methods_share  
FROM product_events  
WHERE event_name = 'payment_methods'
```

```
SELECT  
    COUNT(DISTINCT CASE WHEN buy.user_id IS NOT NULL THEN buy.user_id END) /  
    COUNT(DISTINCT open_app.user_id) AS wallet_purchase_share  
FROM  
    (SELECT DISTINCT user_id FROM product_events WHERE event_name = 'open_app') AS open_appLEFT JOIN  
    (SELECT DISTINCT user_id     FROM product_events  
     WHERE event_name = 'buy'     AND JSONExtractString(parameters, 'payment_method') = 'wallet') AS buy  
ON open_app.user_id = buy.user_id
```


---
# Подробно о моей реализации Баннера

Прежде чем разобрать нереализованные фичи 2-4, расскажу о  реализованном Баннере

## Микросервисная Архитектура баннера
![Screenshot of wb-money](images_for_readme/Pasted%20image%20250614021725.png)


Рассказать про сервисы. Что делают. Как общаются. В каких контейнерах крутятся.

Решение состоит из  4 микросервисов и СУБД Clickhouse. Поля в БД следущие:

| timestamp           | user_id | event_name      | parameters                                                                  |
| ------------------- | ------- | --------------- | --------------------------------------------------------------------------- |
| 2025-05-01 00:03:27 | 1342    | open_app        | {"platform": "ios", "region": "RU"}                                         |
| 2025-05-01 00:04:11 | 1342    | cart            | {"total_amount": 679, "currency": "RUB", "n_goods": 12, "goods_list": ...}  |
| 2025-05-01 00:04:11 | 1342    | payment_methods | {"default_method": "wallet", ...}                                           |
| 2025-05-01 00:05:45 | 1342    | buy             | {"amount": 320, "currency": "RUB", "n_goods": 1, "payment_method":"wallet"} |
| ...                 | ...     | ...             | ...                                                                         |
СУБД Clickhouse запускается в своем докер контейнере.

#### Почему clickhouse а не postgresql:
1. ClickHouse больше подходит для аналитических задач. У него горазда быстрее работает агрегация, фильтры.
2. ClickHouse лучше подходит для транзакционных операций
3. ClickHouse использует column-oriented хранение, эффективное сжатие данных и параллельную обработку запросов
4. ClickHouse лучше масштабируется

С БД по Бинарному протоколу взаимодействуют 3 микросервиса:
1. money-count-service - основной микросервис(завернут в контейнер) на golang, выполняющий основную серверную часть баннера, а именно: по gRPC общается с фронтендом, получает от фронтенда user_id, для этого user_id по бинарному протоколу обращается к СУБД и просит у нее все поля 'buy'  по user_id. Считает все необходимое для GetSavingsResponse и отправляет  по gRPC на фронт. Взаимодейсвие по gRPC фронтенда и бэкенда() описывается в proto:

```
service MoneyService {  
  rpc GetSavings(GetSavingsRequest) returns (GetSavingsResponse);  
}
message GetSavingsRequest {  
  int64 user_id = 1;  
}  
message GetSavingsResponse {  
  enum Status {  
    OK = 0;                      // success  
    USER_NOT_FOUND = 1;  
    NO_PURCHASES = 2;            // нет покупок у пользователя  
    DB_ERROR = 3;                // ошибка бд  
    INVALID_REQUEST = 4;         // Некорректный запрос  
    UNAUTHORIZED = 5;            // Нет доступа к данным пользователя  
    UNKNOWN_ERROR = 6;           // Неизвестная ошибка  
  }  
  Status status = 1;  
  double total_savings = 2;         // Итоговая сумма сэкономленных денег (может быть отрицательной)  
  string currency = 3;  
  int32 total_purchases = 4;        // Количество всех покупок  
  int32 wb_card_purchases = 5;      // Кол-во покупок, совершенных картой WB 
  string message = 6;               // Доп. сообщение  
}
```
2. create-moc-for-db -  микросервис на golang - просто по бинарному протоколу закидывает в БД мок-данные если обратиться к нему ( `curl "http://localhost:3001/generate-mock-data?numUsers=50&startDate=2025-05-01T00:00:00"`), где numUsers - колво, startData- дата
3. wallet_payment_analyzer -  микросервис  на golang - по бинарному протоколу выполняет SQL запросы из вопроса №4.(`curl http://localhost:3002/analytics`)  ответ в json.


Фронтенд money-count-service-frontend (url = `http://localhost:3000/`)также обернут в контейнер. Фронтенд общается с бэком по gRPC. Выдает пользователю по ID сколько денег бы он сэкономил если бы пользовался картой ВБ. При этом валидируются данные: потенциально сэкономленная сумма считается только в рублях и только для заказов оплаченных  wb-кошельком. Серверные ошибки обрабатываются. Также обрабатываются случаи когда, user_id ничего не заказывал, введенный user_id не валидный,  введенный user_id отсутствует в БД.

Решил не включать микросервис по аналитике и микросервис по созданию мок-данных в docker-compose потому что они не нужны для минимально корректной работы баннера


Работа контейнеров:
![Screenshot of wb-money](images_for_readme/Pasted%20image%20250614022236.png)


## Структура проекта и репозитория

Код каждого микросервиса находится в своей папке


## Архитектура С4 Баннера
![Screenshot of wb-money](images_for_readme/Pasted%20image%20250614032811.png)

![Screenshot of wb-money](images_for_readme/Pasted%20image%20250614032827.png)

![Screenshot of wb-money](images_for_readme/Pasted%20image%20250614034305.png)




## Use Cases Баннера

В рамках баннера происходит взаимодействие: пользователь вводит user_id и получает данные

Но если Баннер интегрировать в сайт WB или в приложение, то конечно не нужно будет вводить user_id, его будем подгружать с бэка основного сайта/приложения.

## Инструкция по развертыванию Баннера


1. Запуск Баннера
    ```bash
    docker-compose up
    ```

2. Генерация мок-данных. Предэтим запустить go run  generate-mock-data.go

    ```bash
    curl "http://localhost:3001/generate-mock-data?numUsers=50&startDate=2025-05-01T00:00:00"
    ```

3. Получение аналитики для вопроса 4. Предэтим запустить go run wallet_payment_analyzer.go

    ```bash
    curl "http://localhost:3002/analytics"

    ```

4. Откройте браузер и введите URL: `http://localhost:3000/` - Должен открыться сайт с баннером

## Скриншоты взаимодействия с Баннером

![Screenshot of wb-money](images_for_readme/Pasted%20image%20250614022326.png)
![Screenshot of wb-money](images_for_readme/Pasted%20image%20250614022352.png)
![Screenshot of wb-money](images_for_readme/Pasted%20image%20250614022406.png)


# Вернемся к фичам 2-4

### Вопрос 2: Какую статистику нужно собрать, чтобы понять, имеет ли смысл тратить ресурсы на разработку и тестирование предложенных фич?

Чтобы оценить целесообразность разработки и тестирования фич (геймификация кэшбэка, кэшбэк-бустер для новых пользователей и установка WB-кошелька как способа оплаты по умолчанию), необходимо собрать статистику, которая позволит:
1. Оценить текущую ситуацию с использованием WB-кошелька и кэшбэка.
2. Прогнозировать потенциальный эффект от внедрения фич.
3. Определить риски (например, злоупотребление кэшбэк-бустером).

#### Статистика для анализа:
1. Текущие метрики использования WB-кошелька:
    - Доля пользователей, выбирающих WB-кошелек как метод оплаты (`buy` с `"payment_method": "wallet"` / общее количество `buy`).
    - Средняя сумма транзакции при оплате WB-кошельком (из `buy` с `"payment_method": "wallet"`, параметр `amount`).
    - Доля GMV (Gross Merchandise Value), оплаченного через WB-кошелек (сумма `amount` из `buy` с `"payment_method": "wallet"` / общий GMV).
    - Частота использования WB-кошелька по пользователям (количество `buy` с `"payment_method": "wallet"` на одного `user_id`).

1. Поведение пользователей с кэшбэком:
    - Средний размер кэшбэка на транзакцию (если данные доступны).
    - Доля пользователей, которые активно используют кэшбэк (например, повторные покупки с `"payment_method": "wallet"`).
    - Корреляция между размером кэшбэка и частотой покупок (анализ `buy` событий по `user_id` с учетом кэшбэка).
    - Количество заказов на пользователя (для оценки геймификации: как часто пользователи делают N заказов).

1. Анализ новых пользователей (для кэшбэк-бустера):
    - Конверсия новых пользователей в первую покупку с WB-кошельком (события `open_app` → `buy` с `"payment_method": "wallet"` для новых `user_id`).
    - Среднее время от регистрации до первой покупки (анализ временного интервала между первым `open_app` и `buy`).
    - Доля новых пользователей, которые продолжают использовать WB-кошелек после первой покупки (повторные `buy` с `"payment_method": "wallet"`).

1. Риски и ограничения:
    - Количество аккаунтов на одного человека (анализ дублирования `user_id` по IP, устройству или другим идентификаторам, чтобы оценить риск создания множественных аккаунтов для кэшбэк-бустера).
    - Доля пользователей, переключающих метод оплаты с WB-кошелька на другой при показе `payment_methods` (сравнение `"default_method": "wallet"` и `"payment_method"` в `buy`).
    - Стоимость кэшбэка для бизнеса (анализ текущих затрат на кэшбэк и прогноз при увеличении до 5%).

1. Метрики вовлеченности для геймификации:
    - Частота возврата пользователей в приложение (`open_app` по `user_id` за период).
    - Среднее количество товаров в корзине (`n_goods` из `cart`) и сумма корзины (`total_amount`) для пользователей с разным уровнем кэшбэка.
    - Доля пользователей, достигающих порога N заказов (для оценки, сколько пользователей могут претендовать на повышенный кэшбэк).

1. Технические метрики:
    - Время обработки транзакций с WB-кошельком (для оценки инфраструктурных ограничений при росте использования).
    - Ошибки или отклонения при оплате WB-кошельком (анализ логов, если доступны).


### Вопрос 3: Какое решение можно принять на основе данных A/B-теста? Нужно ли дополнительно исследовать другие показатели?


#### Анализ результатов:
Положительный эффект:
- Установка WB-кошелька как метода оплаты по умолчанию увеличила долю GMV через кошелек на 4 процентных пункта (с 11% до 15%), что указывает на рост использования кошелька.
- Выручка на пользователя корзины с оплатой кошельком выросла на 30% (с 1000 до 1300 рублей), что может быть связано с тем, что пользователи чаще выбирают кошелек для более крупных покупок или из-за удобства предвыбора.
- Эти результаты подтверждают гипотезу, что предвыбор WB-кошелька увеличивает его использование и приносит больше выручки.
  Потенциальное решение:
- На основе текущих данных можно рекомендовать внедрение фичи(WB-кошелек по умолчанию) в продакшен, так как она демонстрирует статистически значимый положительный эффект на ключевые бизнес-метрики (GMV и выручку).
- Однако перед масштабированием необходимо провести дополнительные проверки, чтобы минимизировать риски и убедиться в долгосрочной эффективности.

#### Какие дополнительные показатели нужно исследовать?
1. Доля пользователей, меняющих метод оплаты:
    - Проанализировать, сколько пользователей в группе B переключают метод оплаты с WB-кошелька на другой (сравнить `"default_method": "wallet"` в `payment_methods` с `"payment_method"` в `buy`).
    - Высокий процент переключений может указывать на неудобство или недоверие к кошельку.
    - SQL-запрос:
      ```sql
      SELECT
          COUNT(DISTINCT CASE WHEN JSONExtractString(pm.parameters, 'default_method') = 'wallet'
                              AND JSONExtractString(b.parameters, 'payment_method') != 'wallet'
                              THEN pm.user_id END) / COUNT(DISTINCT pm.user_id) AS switch_rate
      FROM product_events pm
      JOIN product_events b ON pm.user_id = b.user_id
      WHERE pm.event_name = 'payment_methods'
        AND b.event_name = 'buy'
        AND pm.timestamp <= b.timestamp
        AND experiment_group = 'B';
      ```

1. Общий GMV и выручка:
    - Проверить, не снизилась ли общая выручка или GMV в группе B (не только для кошелька, но для всех методов оплаты). Рост доли GMV кошелька может быть результатом перераспределения, а не роста общего объема продаж.
    - SQL-запрос:
      ```sql
      SELECT
          SUM(JSONExtractInt(parameters, 'amount')) AS total_gmv
      FROM product_events
      WHERE event_name = 'buy'
      GROUP BY experiment_group;
      ```

2. Вовлеченность и удержание:
    - Оценить, влияет ли предвыбор кошелька на возвращаемость пользователей (`open_app` через 1, 7, 30 дней после `buy`).
    - Если пользователи воспринимают предвыбор как навязывание, это может снизить лояльность.
    - SQL-запрос:
      ```sql
      SELECT
          COUNT(DISTINCT CASE WHEN o.timestamp > b.timestamp + INTERVAL 7 DAY THEN o.user_id END) / COUNT(DISTINCT b.user_id) AS retention_7d
      FROM product_events b
      LEFT JOIN product_events o ON b.user_id = o.user_id AND o.event_name = 'open_app'
      WHERE b.event_name = 'buy'
      GROUP BY experiment_group;
      ```


3. Сегментация пользователе
    - Проверить, как фича влияет на разные сегменты (новые vs старые пользователи, iOS vs Android, крупные vs мелкие покупки). Возможно, эффект сильнее для определенных групп.
    - SQL-запрос:
      ```sql
      SELECT
          JSONExtractString(parameters, 'platform') AS platform,
          SUM(CASE WHEN JSONExtractString(parameters, 'payment_method') = 'wallet' THEN JSONExtractInt(parameters, 'amount') ELSE 0 END) / SUM(JSONExtractInt(parameters, 'amount')) AS wallet_gmv_share
      FROM product_events
      WHERE event_name = 'buy'
      GROUP BY platform, experiment_group;
      ```

Итог
-  На основе текущих данных фича выглядит перспективной, так как увеличивает ключевые метрики (GMV и выручку кошелька). Можно начать постепенное внедрение (например, для 10% пользователей) с мониторингом дополнительных метрик.

Вывод:
Фича с предвыбором WB-кошелька показала положительный эффект, и ее можно рекомендовать к внедрению, но с осторожностью. Дополнительный анализ конверсии, общего GMV, удержания и пользовательского опыта поможет минимизировать риски и подтвердить долгосрочную выгоду